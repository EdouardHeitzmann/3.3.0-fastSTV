from votekit.elections import ElectionState, Election
from votekit import PreferenceProfile, Ballot
from votekit.utils import score_dict_to_tos_ranking
import pandas as pd
import pytest


class TestElection(Election):
    __test__ = False  # prevents Pytest from trying to collect this
    """
    Elect the first person observed on first ballot. Eliminate second person. Rest remain.
    Discard entire ballot. Repeat for one more round. Scores are just index of letter in string 
    ABCDEF
    """

    def __init__(self, profile: PreferenceProfile, sort_high_low: bool = True):
        def score(profile):
            score_dict = {c: 0 for c in profile.get_candidates()}
            for ballot in profile.ballots:
                for s in ballot.ranking:
                    for c in s:
                        score_dict[c] += "ABCDEF".index(c)
            return score_dict

        super().__init__(profile, score_function=score, sort_high_low=sort_high_low)

    def _next_round(self):
        # 2 round election, so 3 states
        if len(self.election_states) == 3:
            return False
        return True

    def _run_step(
        self, profile: PreferenceProfile, prev_state: ElectionState, store_states=False
    ) -> PreferenceProfile:
        """
        Run one step of an election from the given profile and previous state.

        Args:
            profile (PreferenceProfile): Profile of ballots.
            prev_state (ElectionState): The previous ElectionState.
            store_states (bool, optional): True if `self.election_states` should be updated with the
                ElectionState generated by this round. This should only be True when used by
                `self._run_election()`. Defaults to False.

        Returns:
            PreferenceProfile: The profile of ballots after the round is completed.
        """

        new_profile = PreferenceProfile(ballots=profile.ballots[1:])

        if store_states:
            elected = list(profile.ballots[0].ranking[0])[0]
            eliminated = list(profile.ballots[0].ranking[1])[0]
            remaining = profile.get_candidates()
            remaining.remove(elected)
            remaining.remove(eliminated)
            scores = self.score_function(new_profile)

            new_state = ElectionState(
                round_number=(prev_state.round_number + 1),
                remaining=score_dict_to_tos_ranking(scores, self.sort_high_low),
                elected=tuple([frozenset(elected)]),
                eliminated=tuple([frozenset(eliminated)]),
                scores=scores,
            )

            self.election_states.append(new_state)

        return new_profile


profile = PreferenceProfile(
    ballots=[
        Ballot(ranking=[{"A"}, {"B"}]),
        Ballot(ranking=[{"C"}, {"D"}]),
        Ballot(ranking=[{"E"}, {"F"}]),
    ]
)
profile_1 = PreferenceProfile(
    ballots=[Ballot(ranking=[{"C"}, {"D"}]), Ballot(ranking=[{"E"}, {"F"}])]
)
profile_2 = PreferenceProfile(ballots=[Ballot(ranking=[{"E"}, {"F"}])])

states = [
    ElectionState(
        remaining=(
            frozenset({"F"}),
            frozenset({"E"}),
            frozenset({"D"}),
            frozenset({"C"}),
            frozenset({"B"}),
            frozenset({"A"}),
        ),
        scores={"A": 0, "B": 1, "C": 2, "D": 3, "E": 4, "F": 5},
    ),
    ElectionState(
        round_number=1,
        remaining=(
            frozenset({"F"}),
            frozenset({"E"}),
            frozenset({"D"}),
            frozenset({"C"}),
        ),
        elected=(frozenset({"A"}),),
        eliminated=(frozenset({"B"}),),
        scores={"C": 2, "D": 3, "E": 4, "F": 5},
    ),
    ElectionState(
        round_number=2,
        remaining=(frozenset({"F"}), frozenset({"E"})),
        elected=(frozenset({"C"}),),
        eliminated=(frozenset({"D"}),),
        scores={"E": 4, "F": 5},
    ),
]
e = TestElection(profile)


def test_election_init():
    assert isinstance(e, Election)
    assert e._profile == profile
    assert e.length == 2


def test_election_state_list():
    assert e.election_states == states
    assert e.length == len(e.election_states) - 1


def test_get_elected():
    assert e.get_elected() == e.get_elected(2)  # default behavior is get last round
    assert e.get_elected(0) == []
    assert e.get_elected(1) == [{"A"}]
    assert e.get_elected(2) == [{"A"}, {"C"}]


def test_get_elected_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_elected(-2)


def test_get_eliminated():
    assert e.get_eliminated() == e.get_eliminated(
        2
    )  # default behavior is get last round
    assert e.get_eliminated(0) == []
    assert e.get_eliminated(1) == [{"B"}]
    assert e.get_eliminated(2) == [{"D"}, {"B"}]


def test_get_eliminated_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_eliminated(-2)


def test_get_remaining():
    assert e.get_remaining() == e.get_remaining(2)  # default behavior is get last round
    assert e.get_remaining(0) == [{"F"}, {"E"}, {"D"}, {"C"}, {"B"}, {"A"}]
    assert e.get_remaining(1) == [{"F"}, {"E"}, {"D"}, {"C"}]
    assert e.get_remaining(2) == [{"F"}, {"E"}]


def test_get_remaining_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_remaining(-2)


def test_get_ranking():
    assert e.get_ranking() == e.get_ranking(2)  # default behavior is get last round
    assert e.get_ranking(0) == [{"F"}, {"E"}, {"D"}, {"C"}, {"B"}, {"A"}]
    assert e.get_ranking(1) == [{"A"}, {"F"}, {"E"}, {"D"}, {"C"}, {"B"}]
    assert e.get_ranking(2) == [{"A"}, {"C"}, {"F"}, {"E"}, {"D"}, {"B"}]


def test_get_ranking_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_ranking(-2)


def test_get_profile():
    assert e.get_profile() == e.get_profile(2)  # default behavior is get last round
    assert e.get_profile(0) == profile
    assert e.get_profile(1) == profile_1
    assert e.get_profile(2) == profile_2


def test_get_profile_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_profile(-2)


def test_get_step():
    assert e.get_step() == e.get_step(2)  # default behavior is get last round
    assert e.get_step(0) == (profile, states[0])
    assert e.get_step(1) == (profile_1, states[1])
    assert e.get_step(2) == (profile_2, states[2])


def test_get_step_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_step(-2)


def test_get_status_df():
    round_0 = pd.DataFrame(
        {"Status": ["Remaining"] * 6, "Round": [0] * 6},
        index=["F", "E", "D", "C", "B", "A"],
    )

    round_1 = pd.DataFrame(
        {
            "Status": [
                "Elected",
                "Remaining",
                "Remaining",
                "Remaining",
                "Remaining",
                "Eliminated",
            ],
            "Round": [1] * 6,
        },
        index=["A", "F", "E", "D", "C", "B"],
    )

    round_2 = pd.DataFrame(
        {
            "Status": [
                "Elected",
                "Elected",
                "Remaining",
                "Remaining",
                "Eliminated",
                "Eliminated",
            ],
            "Round": [1, 2, 2, 2, 2, 1],
        },
        index=["A", "C", "F", "E", "D", "B"],
    )

    assert e.get_status_df().equals(
        e.get_status_df(2)
    )  # default behavior is get last round
    assert e.get_status_df(0).equals(round_0)
    assert e.get_status_df(1).equals(round_1)
    assert e.get_status_df(2).equals(round_2)


def test_get_status_df_errors():
    with pytest.raises(ValueError, match="round_number must be -1 or non-negative."):
        e.get_status_df(-2)


def test_score_sort():
    e_low_high = TestElection(profile, sort_high_low=False)

    low_high_states = [
        ElectionState(
            remaining=(
                frozenset({"A"}),
                frozenset({"B"}),
                frozenset({"C"}),
                frozenset({"D"}),
                frozenset({"E"}),
                frozenset({"F"}),
            ),
            scores={"A": 0, "B": 1, "C": 2, "D": 3, "E": 4, "F": 5},
        ),
        ElectionState(
            round_number=1,
            remaining=(
                frozenset({"C"}),
                frozenset({"D"}),
                frozenset({"E"}),
                frozenset({"F"}),
            ),
            elected=(frozenset({"A"}),),
            eliminated=(frozenset({"B"}),),
            scores={"C": 2, "D": 3, "E": 4, "F": 5},
        ),
        ElectionState(
            round_number=2,
            remaining=(frozenset({"E"}), frozenset({"F"})),
            elected=(frozenset({"C"}),),
            eliminated=(frozenset({"D"}),),
            scores={"E": 4, "F": 5},
        ),
    ]

    round_2 = pd.DataFrame(
        {
            "Status": [
                "Elected",
                "Elected",
                "Remaining",
                "Remaining",
                "Eliminated",
                "Eliminated",
            ],
            "Round": [1, 2, 2, 2, 2, 1],
        },
        index=["A", "C", "E", "F", "D", "B"],
    )

    assert e_low_high.election_states == low_high_states
    assert e_low_high.get_status_df(2).equals(round_2)
