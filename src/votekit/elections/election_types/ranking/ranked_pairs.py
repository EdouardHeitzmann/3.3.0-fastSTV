from .abstract_ranking import RankingElection
from ....pref_profile import PreferenceProfile
from ...election_state import ElectionState
from votekit.graphs.pairwise_comparison_graph import (
    pairwise_dict,
    get_dominating_tiers_digraph,
)
import networkx as nx


class RankedPairs(RankingElection):
    """
    See `Ranked Pairs <https://en.wikipedia.org/wiki/Ranked_pairs>`_ for more details.

    Args:
        profile (PreferenceProfile): Profile to conduct election on.
        m (int, optional): Number of seats to elect. Defaults to 1.
        tiebreak (str, optional): Tiebreak method to use. Options are None, 'random', and 'borda'.
            Defaults to None, in which case a tie raises a ValueError.
        fpv_tie_convention (Literal["high", "average", "low"], optional): How to award points
            for tied first place votes. Defaults to "average", where if n candidates are tied for
            first, each receives 1/n points. "high" would award them each one point, and "low" 0.
            Only used by ``score_function`` parameter.

    """

    def __init__(
        self,
        profile: PreferenceProfile,
        m: int = 1,
    ):
        if m == 0:
            raise ValueError("m must be strictly positive")
        if len(profile.candidates_cast) < m:
            raise ValueError("Not enough candidates received votes to be elected.")
        self.m = m

        # TODO: Think about putting this in utils to make lexicographic tiebreaks easier.
        def lexicographic_scores(profile: PreferenceProfile) -> dict[str, float]:
            return {
                c: i for i, c in enumerate(sorted(profile.candidates, reverse=True))
            }

        super().__init__(
            profile,
            score_function=lexicographic_scores,
            sort_high_low=True,
        )

    def _is_finished(self):
        # single round election
        elected_cands = [c for s in self.get_elected() for c in s]

        if len(elected_cands) == self.m:
            return True
        return False

    def _run_step(
        self, profile: PreferenceProfile, prev_state: ElectionState, store_states=False
    ) -> PreferenceProfile:
        """

        Args:
            profile (PreferenceProfile): Profile of ballots.
            prev_state (ElectionState): The previous ElectionState.
            store_states (bool, optional): True if `self.election_states` should be updated with the
                ElectionState generated by this round. This should only be True when used by
                `self._run_election()`. Defaults to False.

        Returns:
            PreferenceProfile: The profile of ballots after the round is completed.
        """
        pairwise = pairwise_dict(profile)
        ordered_winners = {}
        # Determine the Digraph edges
        for (a, b), (weight_a, weight_b) in pairwise.items():
            if weight_a > weight_b:
                ordered_winners[(a, b)] = weight_a - weight_b
            elif weight_b > weight_a:
                ordered_winners[(b, a)] = weight_b - weight_a
            else:
                lex_winner = sorted((a, b))[0]
                ordered_winners[(lex_winner, a if lex_winner == b else b)] = 0

        # Lock the order
        sorted_winners = sorted(
            ordered_winners.items(), key=lambda x: x[1], reverse=True
        )

        graph: nx.DiGraph = nx.DiGraph()
        graph.add_nodes_from(profile.candidates_cast)

        for edge, _ in sorted_winners:
            # Skip cycles
            if nx.has_path(graph, edge[1], edge[0]):
                continue
            graph.add_edge(edge[0], edge[1])

        ordered_candidates = [
            candidate
            for candidate_set in get_dominating_tiers_digraph(graph)
            for candidate in sorted(candidate_set)
        ]

        elected = tuple(frozenset({c}) for c in ordered_candidates[: self.m])
        remaining = tuple(frozenset({c}) for c in ordered_candidates[self.m :])

        new_state = ElectionState(
            round_number=prev_state.round_number + 1,
            elected=elected,
            remaining=remaining,
        )

        self.election_states.append(new_state)

        return profile
